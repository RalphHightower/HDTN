//
// Based on DirectoryWatcher.cpp, original license terms follow.
//
// $Id: //poco/1.4/Foundation/src/DirectoryWatcher.cpp#4 $
//
// Library: Foundation
// Package: Filesystem
// Module:  DirectoryWatcher
//
// Copyright (c) 2012, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
#pragma once

#include <boost/filesystem/path.hpp>
#include <boost/version.hpp>
#if (BOOST_VERSION >= 107200)
#include <boost/filesystem/directory.hpp>
#endif
#include <boost/filesystem/operations.hpp>
#include <boost/ptr_container/ptr_unordered_map.hpp>
#include <boost/bimap.hpp>
#include <boost/make_unique.hpp>
#include <boost/system/error_code.hpp>
#include <boost/system/system_error.hpp>
#include <string>
#include <deque>
#include <vector>

#include <boost/asio.hpp>
#include <boost/thread.hpp>
#include <boost/bind/bind.hpp> //don't include <boost/bind.hpp> to force using boost::placeholders::_1 instead of just _1
#include <boost/scoped_ptr.hpp>
#include <boost/array.hpp>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>

namespace boost {
namespace asio {

class dir_monitor_impl
{

    typedef std::map<std::string, boost::filesystem::directory_entry> dir_entry_map;
    typedef boost::bimap<std::string, int> dir_to_handle_bimap_t;

public:

    static void throw_system_error(const char* msg) {
        //As of Boost v1.66.0, get_system_category was deprecated with language: "Boost.System deprecates the old names, but will provide them when the macro BOOST_SYSTEM_ENABLE_DEPRECATED is defined."
        //Prior versions <= 1.65.1 it said: "Boost.System deprecates the old names, but continues to provide them unless macro BOOST_SYSTEM_NO_DEPRECATED is defined."
        boost::system::system_error e(boost::system::error_code(errno,
#if (BOOST_VERSION < 106600)
            boost::system::get_system_category()),
#else
            boost::system::system_category()),
#endif
            msg);
        boost::throw_exception(e);
    }
    dir_monitor_impl()
        : kqueue_(init_kqueue())
        , run_(true)
    {
        //add a user event (id 0) to allow unblocking of permanently blocking kevent function in the thread loop (without need for timeout)
        //based on https://opensource.apple.com/source/xnu/xnu-1699.24.23/tools/tests/xnu_quick_test/kqueue_tests.c
        struct kevent keventChangeIn;
        EV_SET(&keventChangeIn, 0, EVFILT_USER, EV_ADD, 0, 0, 0);
        if (kevent(kqueue_, &keventChangeIn, 1, NULL, 0, NULL) == -1) {
            static const char* const msg = "boost::asio::dir_monitor_impl(): kevent failed to register user event";
            printf("%s\n", msg);
            throw_system_error(msg);
        }

        work_thread_ptr_ = boost::make_unique<boost::thread>(&boost::asio::dir_monitor_impl::work_thread, this);
    }

    ~dir_monitor_impl()
    {
        // The work thread is stopped and joined.

        destroy();

        if (work_thread_ptr_) {
            work_thread_ptr_->join();
            work_thread_ptr_.reset();
        }
        ::close(kqueue_);
    }

    void add_directory(std::string dirname, int wd)
    {
        boost::unique_lock<boost::mutex> lock(dirs_mutex_);
        if (!dirs_.insert(dir_to_handle_bimap_t::value_type(dirname, wd)).second) {
            printf("cannot add directory %s\n", dirname.c_str());
            return;
        }
        {
            boost::unique_lock<boost::mutex> lock(entries_mutex_);
            scan(dirname, entries_[dirname]);
        }

        struct kevent keventChangeIn;
        static constexpr unsigned eventFilter = NOTE_WRITE | NOTE_DELETE | NOTE_RENAME | NOTE_EXTEND | NOTE_ATTRIB;
        EV_SET(&keventChangeIn, wd, EVFILT_VNODE, EV_ADD | EV_CLEAR, eventFilter, 0, NULL);
        if (kevent(kqueue_, &keventChangeIn, 1, NULL, 0, NULL) == -1) {
            static const char* const msg = "boost::asio::~dir_monitor_impl(): kevent failed to add_directory";
            printf("%s\n", msg);
            throw_system_error(msg);
        }
    }

    void remove_directory(const std::string &dirname)
    {
        boost::unique_lock<boost::mutex> lock(dirs_mutex_);
        if (dirs_.left.erase(dirname) != 1) {
            printf("cannot remove directory %s\n", dirname.c_str());
        }
    }

    void remove_directory(const int descriptor)
    {
        boost::unique_lock<boost::mutex> lock(dirs_mutex_);
        dir_to_handle_bimap_t::right_iterator it = dirs_.right.find(descriptor);
        if (it != dirs_.right.end()) {
            dirs_.right.erase(it);
            //Calling close() on a file  descriptor will remove any kevents that reference the descriptor.
            ::close(descriptor);
        }
        else {
            printf("cannot remove directory by descriptor\n");
        }
    }

    void remove_all_directories()
    {
        boost::unique_lock<boost::mutex> lock(dirs_mutex_);
        for (dir_to_handle_bimap_t::right_iterator it = dirs_.right.begin(); it != dirs_.right.end(); ++it) {
            const int descriptor = it->first;
            //Calling close() on a file  descriptor will remove any kevents that reference the descriptor.
            ::close(descriptor);
        }
        dirs_.clear();
    }

    void destroy()
    {
        remove_all_directories();
        {
            boost::unique_lock<boost::mutex> lock(events_mutex_);
            if (run_)
            {
                run_ = false;
                // trigger the user 0 event, telling work thread to exit
                struct kevent keventChangeIn;
                EV_SET(&keventChangeIn, 0, EVFILT_USER, 0, NOTE_TRIGGER, 0, 0);
                if (kevent(kqueue_, &keventChangeIn, 1, NULL, 0, NULL) == -1) {
                    static const char* const msg = "boost::asio::dir_monitor_impl::destroy: kevent failed to trigger user event";
                    printf("%s\n", msg);
                    throw_system_error(msg);
                }
            }
        }
        events_cond_.notify_all();
    }

    dir_monitor_event popfront_event(boost::system::error_code &ec)
    {
        boost::unique_lock<boost::mutex> lock(events_mutex_);
        while (run_ && events_.empty()) {
            events_cond_.wait(lock);
        }
        dir_monitor_event ev;
        if (!events_.empty())
        {
            ec = boost::system::error_code();
            ev = events_.front();
            events_.pop_front();
        }
        else
            ec = boost::asio::error::operation_aborted;
        return ev;
    }

    void pushback_event(dir_monitor_event ev)
    {
        {
            boost::unique_lock<boost::mutex> lock(events_mutex_);
            if (run_)
            {
                events_.push_back(ev);
            }
        }
        events_cond_.notify_all();
    }

private:
    int init_kqueue()
    {
        int fd = kqueue();
        if (fd == -1)
        {
            static const char* const msg = "boost::asio::dir_monitor_impl::init_kqueue: kqueue failed";
            printf("%s\n", msg);
            throw_system_error(msg);
        }
        return fd;
    }

    void scan(std::string const& dir, dir_entry_map& entries) const
    {
        for (unsigned int attempt = 0; attempt < 1000; ++attempt) {
            boost::system::error_code ec;
            boost::filesystem::directory_iterator it(dir, ec), end;

            if (ec)
            {
                //boost::system::system_error e(ec, "boost::asio::dir_monitor_impl::scan: unable to iterate directories");
                //printf("boost::asio::dir_monitor_impl::scan: unable to iterate directory %s: %s\n", dir.c_str(), ec.what().c_str());
                boost::this_thread::yield();
                //boost::throw_exception(e);
                continue;
            }

            while (it != end)
            {
                entries[(*it).path().native()] = *it;
                ++it;
            }
            return;
        }
        printf("boost::asio::dir_monitor_impl::scan: unable to iterate directory %s\n", dir.c_str());
    }

    void compare(std::string const& dir, dir_entry_map& old_entries, dir_entry_map& new_entries)
    {
        // @todo filename() loses path relative to dir
        // Need to construct with dir as a root_path() and get all paths relative to that.
        for (dir_entry_map::iterator itn = new_entries.begin(); itn != new_entries.end(); ++itn)
        {
            dir_entry_map::iterator ito = old_entries.find(itn->first);
            if (ito != old_entries.end())
            {
                if (!boost::filesystem::equivalent(itn->second.path(), ito->second.path()) ||
                    boost::filesystem::last_write_time(itn->second.path()) != boost::filesystem::last_write_time(ito->second.path()) ||
                    (boost::filesystem::is_regular_file(itn->second.path()) && boost::filesystem::is_regular_file(ito->second.path()) &&
                    boost::filesystem::file_size(itn->second.path()) != boost::filesystem::file_size(ito->second.path())))
                {
                    pushback_event(dir_monitor_event(boost::filesystem::path(dir) / itn->second.path().filename(), dir_monitor_event::modified));
                }
                old_entries.erase(ito);
            }
            else
            {
                pushback_event(dir_monitor_event(boost::filesystem::path(dir) / itn->second.path().filename(), dir_monitor_event::added));
            }
        }
        for (dir_entry_map::iterator it = old_entries.begin(); it != old_entries.end(); ++it)
        {
            pushback_event(dir_monitor_event(boost::filesystem::path(dir) / it->second.path().filename(), dir_monitor_event::removed));
        }
    }

    void work_thread()
    {   
        static constexpr unsigned int MAX_EVENTS_OUT = 10;
        struct kevent keventEventListOut[MAX_EVENTS_OUT];
        while (true)
        {
            int nEvents = kevent(kqueue_, NULL, 0, keventEventListOut, (int)MAX_EVENTS_OUT, NULL); //blocks forever until event

            if (nEvents < 0)
            {
                printf("boost::asio::dir_monitor_impl::work_thread: kevent failed with nEvents == -1");
                return;
            }
            for (int i = 0; i < nEvents; ++i) {
                struct kevent& eventDataOut = keventEventListOut[i];
                if (eventDataOut.flags == EV_ERROR) {
                    printf("boost::asio::dir_monitor_impl::work_thread: kevent failed with flags set to EV_ERROR");
                    return;
                }
                else if (eventDataOut.filter == EVFILT_USER) {
                    if (eventDataOut.ident == 0) {
                        //user event (id 0) triggered from destructor, time to exit work thread
                        return;
                    }
                }
                else if (eventDataOut.fflags & NOTE_WRITE) { //directory was modified
                    boost::unique_lock<boost::mutex> lock(dirs_mutex_);
                    dir_to_handle_bimap_t::right_iterator it = dirs_.right.find(eventDataOut.ident);
                    if (it != dirs_.right.end()) {
                        const std::string& directoryNameThatWasModified = it->second;
                        dir_entry_map new_entries;
                        scan(directoryNameThatWasModified, new_entries);
                        {
                            boost::unique_lock<boost::mutex> lock(entries_mutex_);
                            compare(directoryNameThatWasModified, entries_[directoryNameThatWasModified], new_entries);
                            std::swap(entries_[directoryNameThatWasModified], new_entries);
                        }
                    }
                    else {
                        printf("cannot find descriptor of directory that was modified\n");
                    }
                }
                else if (eventDataOut.fflags & (NOTE_DELETE | NOTE_RENAME)) {
                    printf("monitored directory was deleted or renamed\n");
                    remove_directory(eventDataOut.ident);
                }
            }
        }
    }


    int kqueue_;
    boost::mutex entries_mutex_;
    boost::unordered_map<std::string, dir_entry_map> entries_;
    bool run_;
    std::unique_ptr<boost::thread> work_thread_ptr_;

    boost::mutex dirs_mutex_;
    //boost::ptr_unordered_map<std::string, unix_handle> dirs_;
    dir_to_handle_bimap_t dirs_;

    boost::mutex events_mutex_;
    boost::condition_variable events_cond_;
    std::deque<dir_monitor_event> events_;
};

} // asio namespace
} // boost namespace

